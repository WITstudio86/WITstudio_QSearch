- 下面实例中`TraitA` 和 `TraitB` 都为 TypeA 实现了 `play` 方法
- `TypeA` 自己也实现了 play 方法
- 但是不会存在调用冲突问题

```rust
fn main() {
    struct TypeA;
    
    trait TraitA{
        // 有默认实现
        fn play(&self){
            println!("TraitA play");
        }
    } 

    trait TraitB{
        // 有默认实现
        fn play(&self){
            println!("TraitB play");
        }
    }

    // 两个 trait 都实现给 TypeA
    impl TraitA for TypeA{}
    impl TraitB for TypeA{}

    // TypeA 本身也实现一个 play
    impl TypeA{
        fn play(&self){
            println!("TypeA's play");
        }
    }

    let a = TypeA;
    a.play(); //TypeA's play
    <TypeA as TraitA>::play(&a);//TraitA play
    <TypeA as TraitB>::play(&a);//TraitB play
}
```

tokio 提供了一种合作式（而非抢占式）的任务模型：每个任务 task 都可以看作是一个轻量级的线程，与操作系统线程相对。操作系统默认的线程机制需要消耗比较多的资源，一台普通服务器上能启动的总线程数一般最多也就几千个。而 tokio 的轻量级线程可以在一台普通服务器上创建上百万个。

>基于[tokio 计时器](tokio%20计时器.md)改写
```rust
use std::time::Duration;
use tokio::{task::JoinHandle, time};

// 函数会返回一个 轻量级线程的Future
fn get_feature() -> JoinHandle<String>{
    return tokio::spawn(
        async {
            // 定义时间间隔
            let mut interval = time::interval(Duration::from_millis(2000));
            // 2秒
            interval.tick().await;
            println!("2 秒过去了");
            // 又 2 秒 
            interval.tick().await;
            println!("4 秒过去了");
            "result end".to_owned()
        }
    )
}

#[tokio::main]
async fn main() {
    println!("start");
    // result 就是 get_feature 的 Handle , 相当于这个线程任务的管理者
    let result = get_feature();
    // 下面两行会直接执行 , 上面的代码不会阻塞程序, 因为分配了一个轻量级线程
    println!("other task1");
    println!("other task2");
    // 在需要这个任务值的时候通过 handle 获得结果并使用
    let result = result.await;
    println!("{}",result.unwrap());
    println!("code end")
}
```
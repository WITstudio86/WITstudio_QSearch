# 锁

## Mutex + Arc

- 不管是读还是写同时只存在一个操作者的锁

```rust
use std::sync::Arc;

use tokio::spawn;
use tokio::sync::Mutex;

#[tokio::main]
async fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    // vec[2] = 30;
    let lock = Arc::new(Mutex::new(vec));
    let lock2 = lock.clone();
    // creat two spwan
    spawn(async move {
        let db = lock.lock().await;
        println!("spawn1: {:?}", db);
    });

    spawn(async move {
        let mut db = lock2.lock().await;
        db[3] = 30;

        println!("spawn2: db: {:?}", *db);
    });

 
    println!("code end");
}

```


## Rwlock

- 允许多个读 , 写只能同时存在一个 lock 的锁

```rust
use std::sync::Arc;

use tokio::spawn;
use tokio::sync::RwLock;

#[tokio::main]
async fn main() {
    let vec = vec![1, 2, 3, 4, 5];
    // vec[2] = 30;
    let lock = Arc::new(RwLock::new(vec));
    let lock2 = lock.clone();
    // creat two spwan
    spawn(async move {
        // 多个读取 lock
        let db1 = lock.read().await;
        let db2 = lock.read().await;
        println!("spawn1: db1: {:?} db2: {:?}", *db1, *db2);
    });

    spawn(async move {
        // 写入同时只能有一个
        let mut db = lock2.write().await;
        db[3] = 30;

        println!("spawn2: db: {:?}", *db);
    });

 
    println!("code end");
}

```
> 来源: [01｜快速入门：Rust中有哪些你不得不了解的基础语法？-Rust 语言从入门到实战-极客时间 (geekbang.org)](https://time.geekbang.org/column/article/718865)


# 安装

## 指令

```shell
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
```

## 安装的工具

- cargo
	- `cargo new --bin project_name` 初始化项目
	- `cargo build` 编译项目代码
	- `cargo run` 执行项目代码
- `rustup`
	- 更新工具 , `rustup update stable` 将 Rust Stable 更新到最新
- rust-fmt
	- 格式排版工具 `cargo fmt`
- rust-clippy
	- 严谨性检查 `cargo clippy`
- rustc
	- 编译`.rs` 文件 `rustc filename.rs`
	- 查看版本 `rustc -V`


# 基本语法

## 变量
Rust 中使用 let 关键字定义变量及初始化
```rust
fn main() {
  let a: u32 = 1;
}
```


## 数字类型
- Rust 中的数字类型是区分位数的。
- isize 和 usize 的位数与具体 CPU 架构位数有关。CPU 是 64 位的，它们就是 64 位的，CPU 是 32 位的，它们就是 32 位的
```rust
let a = 10u32;// 这些整数类型可以在写字面量的时候作为后缀跟在后面
let b = 10.0_f32;
```

### 整数字面量
- 十进制字面量 98_222，使用下划线按三位数字一组隔开
- 十六进制字面量 0xff，使用0x开头
- 8进制字面量 0o77，使用0o（小写字母o）开头
- 二进制字面量 0b1111_0000，使用0b开头，按4位数字一组隔开
- 字符的字节表示 b'A'，对一个ASCII字符，在其前面加b前缀，直接得到此字符的ASCII码值

### 布尔
```rust
let a = true;
let b: bool = false;
```

### 字符
```rust
fn main() {
    let c = 'z';
    let z: char = 'ℤ'; 
    let heart_eyed_cat = '😻';
    let t = '中';
}
```
> Rust 的 char 类型存的是 Unicode 散列值。这意味着它可以表达各种符号，比如中文符号、emoji 符号等。在 Rust 中，char 类型在内存中总是占用 4 个字节大小。

### 字符串

- String 内部存储的是 Unicode 字符串的 UTF8 编码，而 char 直接存的是 Unicode Scalar Value（二者的区别可查阅这里）。
- 不能通过下标访问 , 因为即使索引访问成功也只能获取其中一个字节 , 这是没有意义的
- *所有字面量都支持换行书写*
```rust
let hello = String::from("你好");
let a = hello[0];  // 你可能想把“你”字取出来，但实际上这样是错误的
```
> 访问方式: [访问string中的字符](../../其他积累/Rust/访问string中的字符.md)


#### 字符串转义
```rust
fn main() {
    // 将""号进行转义
    let byte_escape = "I'm saying \"Hello\"";
    println!("{}", byte_escape);
    
    // 分两行打印
    let byte_escape = "I'm saying \n 你好";
    println!("{}", byte_escape);
    
    // Windows下的换行符
    let byte_escape = "I'm saying \r\n 你好";
    println!("{}", byte_escape);
    
    // 打印出 \ 本身
    let byte_escape = "I'm saying \\ Ok";
    println!("{}", byte_escape);
    
    // 强行在字符串后面加个0，与C语言的字符串一致。
    let byte_escape = "I'm saying hello.\0";
    println!("{}", byte_escape);
}
```

#### 输出 ASCII 字符或 Unicode 字符

```rust
fn main() {
    // 使用 \x 输入等值的ASCII字符（最高7位）
    let byte_escape = "I'm saying hello \x7f";
    println!("{}", byte_escape);
    
    // 使用 \u{} 输入等值的Unicode字符（最高24位）
    let byte_escape = "I'm saying hello \u{0065}";
    println!("{}", byte_escape);
}
```
> I'm saying hello 
  I'm saying hello e


#### 禁止转义字符串字面量
```rust
fn main() {
    // 字符串字面量前面加r，表示不转义
    let raw_str = r"Escapes don't work here: \x3F \u{211D}";
    println!("{}", raw_str);
    
    // 这个字面量必须使用r##这种形式，因为我们希望在字符串字面量里面保留""
    let quotes = r#"And then I said: "There is no escape!""#;
    println!("{}", quotes);
    
    // 如果遇到字面量里面有#号的情况，可以在r后面，加任意多的前后配对的#号，
    // 只要能帮助Rust编译器识别就行
    let longer_delimiter = r###"A string with "# in it. And even "##!"###;
    println!("{}", longer_delimiter);
}
```



## 数组
- 数组的索引越界的话会
```rust
fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5];
    let a = [1, 2, 3, 4, 5];
}
```
> 数组长度在编译期已经确定 , 所以存储在栈中


## 
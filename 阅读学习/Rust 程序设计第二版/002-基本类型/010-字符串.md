## 字面量

- 使用双引号表示 ,  可以使用`\` 转义
	- 字符串的某一行以反斜线结尾 , 会丢失换行以及下一行开头的空格
- 字符串可以跨多行
- `r` 可以获得原始字符串 , 不包含转义列表 , 在存储 window 路径的时候很常用
	- `#` 可以解决在字符串中包含字符串的情况 ,例如 `"abc"def"123"` 在`r` 的时候无法使用转义符 , 就使用任意数量的`#` 包裹

```rust
fn main() {
    let s = "一行";

    let s = "123
    123";

    println!("{}", s);
    let s = "123\
    123";
    println!("{}", s);
    let s = r"123\
    123";
    println!("{}", s);

    // let s = r"123"23"123";// error
    let s = r##"123"45"678"##;
    println!("{}", s);
}
```
## 字节串

- 字符串也有类似`u8` 自变量的`b` 写法 , 返回的是 u8 字面量切片
```rust
fn main() {
    let method: &[u8; 3] = b"abc";
    println!("{:?}", method);// [97,98,99]
}
```
> 字节串不能包含任意 Unicode 字符，它们只能使用 ASCII 和 \xHH 转义序列。


## 内存中的字符串

Rust 字符串是 Unicode 字符序列，但它们并没有以 char 数组的形式存储在内存中，而是使用了 UTF-8（一种可变宽度编码）的形式。字符串中的每个 ASCII 字符都会存储在单字节中，而其他字符会占用多字节

- String , 可以可以理解为是一个 `Vec<u8>` 
- `&str` 是一个胖指针 , 可以认为是 `&[u8]` 
	- 且不能修改
	- 存在`&mut str` 但是只有`make_ascii_uppercase/lowercase` 可用
- `.len()` 方法返回的是字节数而不是字符为单位
	- 会用`chars.count()` 获得字符数
```rust
fn main() {
    let mut str = "a".to_string();
    str.make_ascii_uppercase();
    println!("str: {} ", str);
}
```

```rust
assert_eq!("ಠ_ಠ".len(), 7);
assert_eq!("ಠ_ಠ".chars().count(), 3)
```

### **访问子字符**

- char 是 Unicode 散列值 , string 存储的是 utf-8 编码的 Unicode , 所以 string 不是 char 的集合
- string 不可以直接通过索引访问字符 , 因为每个字符通过不同数量的元素项存储 , 中文一般是 3 个
- 可以通过`chars` 将字符串转为字符可迭代对象 , 然后通过`.nth()` 从可迭代对象中获取指定字符

```rust
fn main() {
	let a = String::from("hello");
	// println!("{}",a[2]);
	println!("{:?}", a.chars().nth(2).unwrap());
}
```

## String

### 创建String

- `to_string` 方法和 `to_owned`方法
	- 两者作相同的事 , 后者在其他类型上也存在
```rust
let error_message = "too many pets".to_string();
```
- `format!` 宏
	- 与`println!` 类似 , 可以生成格式化后的字符串

```rust
assert_eq!(format!("{}°{:02}′{:02}″N", 24, 5, 23),
           "24°05′23″N".to_string());
```

### 合并为字符串
字符串的数组、切片和向量都有两个方法（`.concat()` 和 `.join(sep)` ），它们会从许多字符串中形成一个新的 String。
```rust
let bits = vec!["veni", "vidi", "vici"];
assert_eq!(bits.concat(), "venividivici");
assert_eq!(bits.join(", "), "veni, vidi, vici");
```

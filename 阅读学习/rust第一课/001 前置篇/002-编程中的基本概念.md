# 编程中的基本概念

## 数据

### 值和类型
- 值无法摆脱类型描述 , 不同类型下的意义可能不同
- 类型一般分为两种
	- 原始类型, 所有原始类型的大小都是固定的 , 都存储在栈上
	- 组合类型
		- ==结构体(逻辑与 , 多个类型同时表达)==: 多个类型组合在一起共同表达一个值的复杂数据结构
		- ==联合标签(逻辑或 , 其中某一个类型)==: 
			- 可以存储一组不同但固定的类型中的某个类型的对象，具体是哪个类型由其标签决定。
			- 枚举就是一种联合标签 , 不过时简化版本的 , 只保留了标签

### 指针和引用

- 指针和引用都可以解引用获取数据的内存地址
	- 指针理论上可以解引用为任意数据类型
	- 引用只能解引用为指向数据的类型
```rust
fn main(){

    let s = "Hello".to_string();
    println!("存储地址: ss:{:p} , s:{:p} , 实际长度:{} , 容量:{} , 当前类型所占字节数 ss{} , s{}",
        &"Hello" , 
        &s , 
        s.len() , 
        s.capacity() , 
        std::mem::size_of_val(&"Hello") ,
        std::mem::size_of_val(&s) 
    );
}
```
> 代码中的 s 就是一个指向堆内 String 数据的指针, 包含了数据地址 , 长度, 容量,3 个 word , 64 位系统下每个 word 占 8 字节 ,所以s 占栈中的 24 字节
> 这种比普通指针携带更多数据的指针被称为胖指针


## 代码

### 函数 , 方法 , 闭包

- 函数
	- 对一系列代码的封装
- 方法
	- 在类或者对象中的函数的视线 , 往往和对象的指针发生关系
	- 例如: python 中的 self , JavaScript 中的 this
- 闭包
	- 一种特殊的函数, 可以存储当前函数所在上下文中与当前函数相关的自由变量

### 接口与虚表

- 接口
	- 一种将功能的实现与使用分离的抽象层 , 大大提高了代码的可扩展性 , 提高复用性
- 虚标
	- 在使用接口引用数据的时候当前代码就实现了多态 , 但是关于接口的引用中 , 变量的类型会被抹掉 , 无法从一个指针中分析出这个引用具备什么样的能力
	- 所以生成这个引用的时候就需要生成一个胖指针 , 除了指向数据本身之外还需要涵盖当前这个接口所只是的方法列表 , 这个列表就是虚表
	- ![](附件/Pasted%20image%2020240625172909.png)

## 运行方式

### 并发和并行

- 并发是同时处理多个事件的能力
- 并行是一种同时处理多个事件的方式
- 当系统拥有多个 CPU core 的时候有并发能力的代码就可以并行运行
- 一般高并发语言会在程序中嵌入一个 M:N 的调度器 , 将 M 个并发任务分配给 N 个 CPU core

### 同步和异步

- 同步执行保证了程序的因果关系
- 异步允许在一个任务开始执行之后 , 其他与当前这个任务没有因果关系的任务可以正常执行 , 而不必等待当前任务执行完毕

- 异步的结果一般是使用 promise 存储 , 它有 3 个状态
	- 未运行
	- 等待态: 还未执行完毕
	- 结果态: 成功解析出值 , 或者失败

- async 和 await 是对 promise 的封装 , 可以将异步代码像同步代码一样书写
	- 可读性更高
	- async : 定义一个异步任务
	- await : 像同步代码一样编写代码时运行一个异步任务


## 泛型编程

泛型编程通过参数化让数据结构像函数一样延迟绑定，提升其通用性，类型的参数可以用接口约束，使类型满足一定的行为，同时，在使用泛型结构时，我们的代码也需要更高的抽象度。


# 思考
1. 有一个指向某个函数的指针，如果将其解引用成一个列表，然后往列表中插入一个元素，请问会发生什么？（对比不同语言，看看这种操作是否允许，如果允许会发生什么）
	1. rust 不允许解引用乘列表 , 类型不一致
	2. python 和 javascript 等弱类型语言可以
2. 要构造一个数据结构 Shape，可以是 Rectangle、 Circle 或是 Triangle，这三种结构见如下代码。请问 Shape 类型该用什么数据结构实现？怎么实现？
	1. 枚举
```rust
struct Rectangle { a: f64, b: f64,}
struct Circle { r: f64,}
struct Triangle { a: f64, b: f64, c: f64,}
```
1. 对于上面的三种结构，如果我们要定义一个接口，可以计算周长和面积，怎么计算？
	1. 为他们实现对应 trait

```rust
trait Calculate{
    // 计算周长
    fn area(&self) -> f64;
    // 计算面积
    fn perimeter(&self) -> f64;
}

struct Rectangle { a: f64, b: f64,}
struct Circle { r: f64,}
struct Triangle { a: f64, b: f64, c: f64,}


enum Shape{
    Rectangle(Rectangle),
    Circle(Circle),
    Triangle(Triangle),
}

impl Calculate for Shape{
    fn area(&self) -> f64{
        match self {
            Shape::Rectangle(rect) => rect.a * rect.b,
            Shape::Circle(circle) => std::f64::consts::PI * circle.r * circle.r,
            Shape::Triangle(triangle) => triangle.a * triangle.b / 2.0,
        }
    }
    fn perimeter(&self) -> f64{
        match self {
            Shape::Rectangle(rect) => 2.0 * (rect.a + rect.b),
            Shape::Circle(circle) => 2.0 * std::f64::consts::PI * circle.r,
            Shape::Triangle(triangle) => triangle.a + triangle.b + triangle.c,
        }
    }
}

fn main(){
    let rect = Rectangle { a: 3.0, b: 4.0,};
    let circle = Circle { r: 5.0,};
    let triangle = Triangle { a: 3.0, b: 4.0, c: 5.0,};
    let shape_rect = Shape::Rectangle(rect);
    let shape2_cir = Shape::Circle(circle);
    let shape3_tri = Shape::Triangle(triangle);
    println!("Area: {}", Shape::area(&shape_rect));
    println!("Perimeter: {}", Shape::perimeter(&shape_rect));
    println!("Area: {}", Shape::area(&shape2_cir));
    println!("Perimeter: {}", Shape::perimeter(&shape2_cir));
    println!("Area: {}", Shape::area(&shape3_tri));
    println!("Perimeter: {}", Shape::perimeter(&shape3_tri));
}
```
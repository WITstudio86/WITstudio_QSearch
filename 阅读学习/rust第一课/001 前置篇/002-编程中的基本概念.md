# 编程中的基本概念

## 数据

### 值和类型
- 值无法摆脱类型描述 , 不同类型下的意义可能不同
- 类型一般分为两种
	- 原始类型, 所有原始类型的大小都是固定的 , 都存储在栈上
	- 组合类型
		- ==结构体(逻辑与 , 多个类型同时表达)==: 多个类型组合在一起共同表达一个值的复杂数据结构
		- ==联合标签(逻辑或 , 其中某一个类型)==: 
			- 可以存储一组不同但固定的类型中的某个类型的对象，具体是哪个类型由其标签决定。
			- 枚举就是一种联合标签 , 不过时简化版本的 , 只保留了标签

### 指针和引用

- 指针和引用都可以解引用获取数据的内存地址
	- 指针理论上可以解引用为任意数据类型
	- 引用只能解引用为指向数据的类型
```rust
fn main(){

    let s = "Hello".to_string();
    println!("存储地址: ss:{:p} , s:{:p} , 实际长度:{} , 容量:{} , 当前类型所占字节数 ss{} , s{}",
        &"Hello" , 
        &s , 
        s.len() , 
        s.capacity() , 
        std::mem::size_of_val(&"Hello") ,
        std::mem::size_of_val(&s) 
    );
}
```
> 代码中的 s 就是一个指向堆内 String 数据的指针, 包含了数据地址 , 长度, 容量,3 个 word , 64 位系统下每个 word 占 8 字节 ,所以s 占栈中的 24 字节
> 这种比普通指针携带更多数据的指针被称为胖指针


## 代码

### 函数 , 方法 , 闭包

- 函数
	- 对一系列代码的封装
- 方法
	- 在类或者对象中的函数的视线 , 往往和对象的指针发生关系
	- 例如: python 中的 self , JavaScript 中的 this
- 闭包
	- 一种特殊的函数, 可以存储当前函数所在上下文中与当前函数相关的自由变量

### 接口与虚表

- 接口
	- 一种将功能的实现与使用分离的抽象层 , 大大提高了代码的可扩展性 , 提高复用性
- 虚标
	- 在使用接口引用数据的时候当前代码就实现了多态 , 但是关于接口的引用中 , 变量的类型会被抹掉 , 无法从一个指针中分析出这个引用具备什么样的能力
	- 所以生成这个引用的时候就需要生成一个胖指针 , 除了指向数据本身之外还需要涵盖当前这个接口所只是的方法列表 , 这个列表就是虚表
	- ![](附件/Pasted%20image%2020240625172909.png)

## 运行方式

### 并发和并行

- 并发是同时处理多个事件的能力
- 并行是一种同时处理多个事件的方式
- 当系统拥有多个 CPU core 的时候有并发能力的代码就可以并行运行
- 一般高并发语言会在程序中嵌入一个 M:N 的调度器 , 将 M 个并发任务分配给 N 个 CPU core

### 同步和异步

- 同步执行保证了程序的因果关系
- 异步允许在一个任务开始执行之后 , 其他与当前这个任务没有因果关系的任务可以正常执行 , 而不必等待当前任务执行完毕

- 异步的结果一般是使用 promise 存储 , 它有 3 个状态
	- 未运行
	- 等待态: 还未执行完毕
	- 结果态: 成功解析出值 , 或者失败

- async 和 await 是对 promise 的封装 , 可以将异步代码像同步代码一样书写
	- 可读性更高
	- async : 定义一个异步任务
	- await : 像同步代码一样编写代码时运行一个异步任务


## 泛型编程

泛型编程通过参数化让数据结构像函数一样延迟绑定，提升其通用性，类型的参数可以用接口约束，使类型满足一定的行为，同时，在使用泛型结构时，我们的代码也需要更高的抽象度。


# 思考

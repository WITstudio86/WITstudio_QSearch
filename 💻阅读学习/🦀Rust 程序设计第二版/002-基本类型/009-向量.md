- `Vec<T>` 一个可调整大小的 T 类型的数组
- 例如`reverse` 等方法也都是定义在切片上的
- `Vec<T>` 由 3 个值组成：指向元素在堆中分配的缓冲区（该缓冲区由 `Vec<T>` 创建并拥有）的指针、缓冲区能够存储的元素数量，以及它现在实际包含的数量（也就是它的长度）
	- 当元素超出最大容量的时候 , 会重新分配空间 , 复制数据 , 然后zhi'xiang

## 创建
- `vec!` 宏像字面量一样创建 Vec

```rust
fn main() {
    let a = vec![1,2,3];
    //  相当于 Vec::new() 之后 push 多个元素
    let mut a = Vec::new();
    a.push(1);
    a.push(2);
    a.push(3);
}
```
- 可以像[008-数组](008-数组.md)一样给定重复一定次数的值作为 Vec 的初始量
```rust
fn new_pixel_buffer(rows: usize, cols: usize) -> Vec<u8> {
    vec![0; rows * cols]
}
```
> 由于长度不是类型签名的一部分, 可以动态更改 , 不需要在编译器就确定长度 , 所以这里可以使用变量甚至表达式

- 从一个迭代器生成的值构建向量
```rust
fn main() {
    let mut arr: Vec<i32> = (1..=5).collect();
    assert_eq!(arr, vec![1, 2, 3, 4, 5])
}
```
> 	要注意此处的的类型声明是必须的 , 因为`collect()` 可以构建出不同类型的集合 , **不仅仅是向量**
## 操作元素

- 追加元素
```rust
fn main() {
    let mut a = vec![1, 2, 3];
    a.push(4);
    println!("{:?}", a);
}
```


